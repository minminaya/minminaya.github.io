<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/avatar.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="CropView从入门到放弃本篇我会带你去从零设计一款裁剪旋转的View  你需要准备的裁剪的View最关键的是裁剪框的绘制和手势的调整，另外还有最核心的裁剪功能就是调用方法createBitmap去裁剪得到目标图片。 //图片裁剪的核心功能Bitmap.createBitmap(originalBitmap,//原图                 cropX,//图片裁剪横坐标开始位置">
<meta property="og:type" content="article">
<meta property="og:title" content="Android裁剪旋转CropView从入门到放弃">
<meta property="og:url" content="http://hexo.minminaya.cn/2018/04/28/Android裁剪旋转CropView从入门到放弃/index.html">
<meta property="og:site_name" content="minminaya">
<meta property="og:description" content="CropView从入门到放弃本篇我会带你去从零设计一款裁剪旋转的View  你需要准备的裁剪的View最关键的是裁剪框的绘制和手势的调整，另外还有最核心的裁剪功能就是调用方法createBitmap去裁剪得到目标图片。 //图片裁剪的核心功能Bitmap.createBitmap(originalBitmap,//原图                 cropX,//图片裁剪横坐标开始位置">
<meta property="og:locale" content="zh">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3515789-63ae083d55d28b8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3515789-740e81f79d8e8e9f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3515789-abb7f50c6abc211f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3515789-ed294a65201cd8cf.gif?imageMogr2/auto-orient/strip">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/3515789-0aa70fedd860fe33.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2019-03-28T14:42:14.089Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android裁剪旋转CropView从入门到放弃">
<meta name="twitter:description" content="CropView从入门到放弃本篇我会带你去从零设计一款裁剪旋转的View  你需要准备的裁剪的View最关键的是裁剪框的绘制和手势的调整，另外还有最核心的裁剪功能就是调用方法createBitmap去裁剪得到目标图片。 //图片裁剪的核心功能Bitmap.createBitmap(originalBitmap,//原图                 cropX,//图片裁剪横坐标开始位置">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/3515789-63ae083d55d28b8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hexo.minminaya.cn/2018/04/28/Android裁剪旋转CropView从入门到放弃/">





  <title>Android裁剪旋转CropView从入门到放弃 | minminaya</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">minminaya</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="https://github.com/minminaya" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hexo.minminaya.cn/2018/04/28/Android裁剪旋转CropView从入门到放弃/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="minminaya">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="minminaya">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android裁剪旋转CropView从入门到放弃</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-28T13:21:10+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/04/28/Android裁剪旋转CropView从入门到放弃/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/04/28/Android裁剪旋转CropView从入门到放弃/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/04/28/Android裁剪旋转CropView从入门到放弃/" class="leancloud_visitors" data-flag-title="Android裁剪旋转CropView从入门到放弃">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="CropView从入门到放弃"><a href="#CropView从入门到放弃" class="headerlink" title="CropView从入门到放弃"></a>CropView从入门到放弃</h1><p>本篇我会带你去从零设计一款裁剪旋转的View</p>
<hr>
<h1 id="你需要准备的"><a href="#你需要准备的" class="headerlink" title="你需要准备的"></a>你需要准备的</h1><p>裁剪的View最关键的是裁剪框的绘制和手势的调整，另外还有最核心的裁剪功能就是调用方法createBitmap去裁剪得到目标图片。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图片裁剪的核心功能</span></span><br><span class="line"><span class="selector-tag">Bitmap</span><span class="selector-class">.createBitmap</span>(originalBitmap,<span class="comment">//原图</span></span><br><span class="line">                 cropX,<span class="comment">//图片裁剪横坐标开始位置</span></span><br><span class="line">                 cropY,<span class="comment">//图片裁剪纵坐标开始位置</span></span><br><span class="line">                 cropWidth,<span class="comment">//要裁剪的宽度</span></span><br><span class="line">                 cropHeight);<span class="comment">//要裁剪的高度</span></span><br></pre></td></tr></table></figure>
<ul>
<li>1、裁剪框的绘制无非就是一个透明的方形和灰色透明度的方形之外的区域（如下图红色箭头所指区域）、裁剪框的绘制关键的地方在于裁剪的Rect区域的确定</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3515789-63ae083d55d28b8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="示意图"></p>
<ul>
<li>2、手势调整裁剪框的边角、四周边。裁剪控件可以拖动的边界为上图的紫色箭头区域，<strong>并且有一个点击所在点区域的周边也可以正常去控制边界的拖动，说明有一个动态的范围</strong></li>
</ul>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>为了能正常的显示图片的缩放比例和旋转、居中等，可以考虑自己控制Bitmap的各项绘制参数。</p>
<h5 id="一、测量"><a href="#一、测量" class="headerlink" title="一、测量"></a>一、测量</h5><p>主要是Padding值的处理</p>
<h5 id="二、布局"><a href="#二、布局" class="headerlink" title="二、布局"></a>二、布局</h5><ul>
<li>1、Bitmap中心点的确定</li>
<li>2、图片比例的确定</li>
<li>3、图片Bitmap参数的确定（比如旋转。放大）</li>
<li>4、图片显示区域的确定</li>
<li>5、裁剪框区域的确定</li>
</ul>
<h5 id="三、绘制"><a href="#三、绘制" class="headerlink" title="三、绘制"></a>三、绘制</h5><ul>
<li>1、画背景</li>
<li>2、画Bitmap</li>
<li>3、画裁剪框</li>
<li>4、画边界线</li>
<li>5、画指导线</li>
<li>6、画定制四边角的图案</li>
</ul>
<h5 id="四、添加MotionEvent控制"><a href="#四、添加MotionEvent控制" class="headerlink" title="四、添加MotionEvent控制"></a>四、添加MotionEvent控制</h5><ul>
<li>1、按下时计算点击的区域位置</li>
<li>2、根据第1步点击的区域去判断需不需要对边界进行Move处理</li>
<li>3、抬起时恢复默认的处理状态</li>
</ul>
<h5 id="五、旋转翻转处理"><a href="#五、旋转翻转处理" class="headerlink" title="五、旋转翻转处理"></a>五、旋转翻转处理</h5><ul>
<li>1、左右翻转</li>
<li>2、旋转处理</li>
</ul>
<h5 id="六、裁剪"><a href="#六、裁剪" class="headerlink" title="六、裁剪"></a>六、裁剪</h5><ul>
<li>1、对获取的bitmap进行旋转处理</li>
<li>2、计算裁剪的原图</li>
<li>3、对图片进行翻转处理</li>
<li>4、拿到裁剪后的图</li>
</ul>
<h5 id="七、开放属性Style"><a href="#七、开放属性Style" class="headerlink" title="七、开放属性Style"></a>七、开放属性Style</h5><h5 id="八、使用"><a href="#八、使用" class="headerlink" title="八、使用"></a>八、使用</h5><hr>
<h1 id="额外需要首先考虑的"><a href="#额外需要首先考虑的" class="headerlink" title="额外需要首先考虑的"></a>额外需要首先考虑的</h1><p>首先思考我们的控件大概需要什么动态的属性，为了以后方便扩展业务或者功能的精确控制</p>
<ul>
<li>1、裁剪框有一个最小的矩形大小，说明要限制裁剪框的长度宽度，一般为正方形（本例中设计为了正方形，当然解析到该块内容时我会顺便说下如何实现长宽不一样的裁剪框）。此处需要属性为<strong>裁剪框最小边长</strong></li>
<li>2、裁剪框外围除了画Bitmap之外，会存在除了Bitmap之外的空白区域，这里希望能控制他们的颜色。此处需要属性为<strong>窗口背景颜色</strong></li>
<li>3、由于我们要自定义Bitmap区域的绘制，类似ImageView控件，我们需要src属性来引入图片内容。此处需要属性为<strong>src</strong></li>
<li>4、上面讲过，手势点击边界或者角时，点击所在点区域的周边也可以正常去控制边界的拖动，说明有一个动态的范围。这个范围也希望是可以控制的。此处需要属性为<strong>触摸边界的大小范围</strong></li>
<li>5、颜色的比如有：<strong>裁剪内框的颜色</strong>，<strong>裁剪外框的颜色</strong>，<strong>边界线的颜色</strong>，<strong>裁剪框指导线的颜色</strong>，<strong>四周边角自定义点的图案的颜色</strong></li>
<li>6、尺寸的比如：<strong>边框线的宽度</strong>，<strong>指导线的宽度</strong>，<strong>四周边角线宽度</strong>、<strong>长度</strong>（或者圆圈的半径）</li>
<li>7、<strong>图片初始化的比例</strong></li>
<li>8、根据默认打开裁剪控件时的状态确定开关类属性：<strong>裁剪框的是否绘制</strong></li>
<li>9、如果说有时候指导线是想要点击才拖动裁剪框才显示，那么还要添加<strong>指导线的绘制开关</strong></li>
<li>10、同理，<strong>四边角自定义图案也需要开关</strong></li>
<li>11、如果你想的够多，那么这些边角图案有时候可能还会加入类似button的点击之后放大图案的需求，那么这个时候你还需要添加一个开关用来控制要不要开启边角动画（逃）</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/3515789-740e81f79d8e8e9f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/3515789-abb7f50c6abc211f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<hr>
<h2 id="一、测量-1"><a href="#一、测量-1" class="headerlink" title="一、测量"></a>一、测量</h2><p>测量View的大小，主要是处理Padding的值，甚至某些情况要专门对wrap_content属性做专门的处理。对Padding进行处理如下<br><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> viewWidth = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> viewHeight = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">       setMeasuredDimension(viewWidth, viewHeight);</span><br><span class="line">       mViewWidth = viewWidth - getPaddingLeft() - getPaddingRight();</span><br><span class="line">       mViewHeight = viewHeight - getPaddingTop() - getPaddingBottom();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>对左右Padding进行了处理，最终得到的是CropView内容的区域的实际宽高</p>
<hr>
<h2 id="二、布局-1"><a href="#二、布局-1" class="headerlink" title="二、布局"></a>二、布局</h2><p>这一部分只要是对Bitmap中心点、图片比例、裁剪框区域的确定，布局代码如下，为了提高性能，这里只有在图片已设置到View之后<figure class="highlight plain"><figcaption><span>```有值的时候才进行布局，</span></figcaption><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">@Override</span><br><span class="line">    protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</span><br><span class="line">        if (getDrawable() != null) &#123;</span><br><span class="line">            doLayout(mViewWidth, mViewHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight pony"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对图片进行布局</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param viewWidth</span></span><br><span class="line"><span class="comment">     * @param viewHeight</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private void doLayout(int viewWidth, int viewHeight) &#123;</span><br><span class="line">        <span class="keyword">if</span> (viewHeight == <span class="number">0</span> || viewWidth == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算中心点</span></span><br><span class="line">        <span class="type">PointF</span> pointF = <span class="function"><span class="keyword">new</span> <span class="title">PointF</span>(getPaddingLeft() + <span class="title">viewWidth</span> * 0.5<span class="title">f</span>, <span class="title">getPaddingTop</span>() + <span class="title">viewHeight</span> * 0.5<span class="title">f</span>);</span></span><br><span class="line"><span class="function">        <span class="comment">//保存中心点</span></span></span><br><span class="line"><span class="function">        <span class="title">setCenter</span>(pointF);</span></span><br><span class="line"><span class="function">        <span class="comment">//计算放大比例和保存比例</span></span></span><br><span class="line"><span class="function">        <span class="title">setScale</span>(calcScale(viewWidth, viewHeight, mImgAngle));</span></span><br><span class="line"><span class="function">        <span class="comment">//Bitmap的举证变换</span></span></span><br><span class="line"><span class="function">        <span class="title">setMatrix</span>();</span></span><br><span class="line"><span class="function">        <span class="title">RectF</span> <span class="title">rectF</span> = <span class="title">new</span> <span class="title">RectF</span>(<span class="number">0</span>, <span class="number">0</span>, mImgWidth, mImgHeight);</span></span><br><span class="line"><span class="function">        <span class="comment">//图片Bitmap的实际区域</span></span></span><br><span class="line"><span class="function">        <span class="title">mImageRectF</span> = <span class="title">calcImageRect</span>(rectF, mMatrix);</span></span><br><span class="line"><span class="function">		<span class="comment">//计算裁剪框的Rect区域</span></span></span><br><span class="line"><span class="function">        <span class="title">mFrameRectF</span> = <span class="title">calculateFrameRect</span>(mImageRectF);</span></span><br><span class="line"><span class="function">		<span class="comment">//标记为初始化完成</span></span></span><br><span class="line"><span class="function">        <span class="title">mIsInitialized</span> = <span class="title">true</span>;</span></span><br><span class="line"><span class="function">        <span class="title">invalidate</span>();</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="1、Bitmap中心点的确定"><a href="#1、Bitmap中心点的确定" class="headerlink" title="1、Bitmap中心点的确定"></a>1、Bitmap中心点的确定</h5><p>这个没什么好说的，就是View除了Padding区域外x，y取中点</p>
<h5 id="2、图片比例的确定"><a href="#2、图片比例的确定" class="headerlink" title="2、图片比例的确定"></a>2、图片比例的确定</h5><p>这里开始会用到一些变量（或者是属性）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 旋转角度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mImgAngle = <span class="number">0.0f</span>;</span><br><span class="line"> <span class="comment">// 图片宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mImgWidth = <span class="number">0.0f</span>;</span><br><span class="line"><span class="comment">// 图片高度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mImgHeight = <span class="number">0.0f</span>;</span><br><span class="line"><span class="comment">// 放大比例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mCropScale = <span class="number">1.0f</span>;</span><br></pre></td></tr></table></figure>
<p>计算比例的代码如下，其实就是图片的宽高之比</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">private <span class="keyword">float</span> calcScale(<span class="keyword">int</span> viewWidth, <span class="keyword">int</span> viewHeight, <span class="keyword">float</span> <span class="keyword">angle</span>) &#123;</span><br><span class="line">        mImgWidth = getDrawable().getIntrinsicWidth();</span><br><span class="line">        mImgHeight = getDrawable().getIntrinsicHeight();</span><br><span class="line">        <span class="keyword">if</span> (mImgWidth &lt;= <span class="number">0</span>)</span><br><span class="line">            mImgWidth = viewWidth;</span><br><span class="line">        <span class="keyword">if</span> (mImgHeight &lt;= <span class="number">0</span>)</span><br><span class="line">            mImgHeight = viewHeight;</span><br><span class="line">        <span class="keyword">float</span> viewRatio = (<span class="keyword">float</span>) viewWidth / (<span class="keyword">float</span>) viewHeight;</span><br><span class="line">        <span class="comment">//旋转的情况</span></span><br><span class="line">        <span class="keyword">float</span> imgRatio = getRotatedWidth(<span class="keyword">angle</span>) / getRotatedHeight(<span class="keyword">angle</span>);</span><br><span class="line">        <span class="keyword">float</span> <span class="keyword">scale</span> = <span class="number">1.0</span>f;</span><br><span class="line">        <span class="keyword">if</span> (imgRatio &gt;= viewRatio) &#123;</span><br><span class="line">            <span class="keyword">scale</span> = viewWidth / getRotatedWidth(<span class="keyword">angle</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imgRatio &lt; viewRatio) &#123;</span><br><span class="line">            <span class="keyword">scale</span> = viewHeight / getRotatedHeight(<span class="keyword">angle</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">scale</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先拿到Drawable的固有宽宽高，接着对图片的宽高mImgWidth、mImgHeight进行边界控制，然后计算出图片的长宽比例，要是有旋转的情况那么viewRatio的值要拿到旋转后的宽高来判断，这里关键就是怎么样拿到旋转后的宽高，<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>private float getRotatedWidth(float angle) {<br>        return getRotatedWidth(angle, mImgWidth, mImgHeight);<br>    }</p>
<p>private float getRotatedWidth(float angle, float width, float height) {<br>        return angle % 180 == 0 ? width : height;<br>    }<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">最后会把放大当前的图片比例保存下来</span><br></pre></td></tr></table></figure></p>
<pre><code>/**
 * 保存比例
 *
 * @param scale
 */
private void setScale(float scale) {
    mCropScale = scale;
}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">3</span>、图片Bitmap参数的确定（比如旋转。放大）</span><br><span class="line">接下来会对图片的平移或者放大比例进行调整</span><br><span class="line"></span><br><span class="line">用到属性如下</span><br></pre></td></tr></table></figure>
<p>// 图形的矩阵类<br>private Matrix mMatrix = null;<br>// 居中中点的矩型区域<br>private PointF mCenter = new PointF();<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">并且矩阵类我们会在构造方法里进行初始化</span><br></pre></td></tr></table></figure></p>
<p> mMatrix = new Matrix();<br><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">一张Bitmap图片加载到<span class="built_in">View</span>默认情况下一般是这样</span><br><span class="line">![](https:<span class="comment">//upload-images.jianshu.io/upload_images/3515789-40995be52e7605eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line">那我们需要做的是将它平移到中点，并且比例放大到我们想要的比例</span><br><span class="line"></span><br><span class="line">所以，<span class="keyword">Matrix</span>变化如下，先对其做平移操作，平移距离是Bitmap显示区域中点到屏幕中点的。放大是以屏幕中心点为放大原点，然后X，Y进行整比例的放大，后面考虑到我们要用到旋转操作，也加了旋转的<span class="keyword">Matrix</span>操作。</span><br></pre></td></tr></table></figure></p>
<pre><code> /**
 * 重设矩阵，平移缩放旋转操作
 */
private void setMatrix() {
    mMatrix.reset();
    mMatrix.setTranslate(mCenter.x - mImgWidth * 0.5f, mCenter.y - mImgHeight * 0.5f);
    mMatrix.postScale(mCropScale, mCropScale, mCenter.x, mCenter.y);
    mMatrix.postRotate(mImgAngle, mCenter.x, mCenter.y);

}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">##### <span class="number">4</span>、图片显示区域的确定</span><br><span class="line">接下来会用到很多关于裁剪框的区域和图片显示区域的Rect变量，我们可以一次性全部定义了它们</span><br><span class="line">![](https:<span class="comment">//upload-images.jianshu.io/upload_images/3515789-54414ba18edeb6d6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br></pre></td></tr></table></figure>
<pre><code>// 图形的矩阵类
private Matrix mMatrix = null;
// 图片的rectf区域
private RectF mImageRectF;
// 裁剪框的RectF
private RectF mFrameRectF;
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>RectF rectF = new RectF(0, 0, mImgWidth, mImgHeight);
    mImageRectF = calcImageRect(rectF, mMatrix);
     /**
 * 将Matrix映射到rect
 *
 * @param rect
 * @param matrix
 * @return
 */
private RectF calcImageRect(RectF rect, Matrix matrix) {
    RectF applied = new RectF();
    matrix.mapRect(applied, rect);
    return applied;
}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">根据Img长宽初始化一个新的Rect区域，然后将变化后的Matrix应用到Rect</span><br><span class="line"></span><br><span class="line">##### <span class="number">5</span>、裁剪框区域的确定</span><br><span class="line"></span><br><span class="line">裁剪框的绘制会涉及到多种比例的变化，因此这部分会是我们最复杂的一块，首先我们先定义裁剪的模式，一般情况下，裁剪模式分为充满View四周不能控制型、自由控制型、比例型三种。</span><br><span class="line"></span><br><span class="line">定义一个枚举类来标记裁剪模式，这里比例型有<span class="number">7</span>种，其实定义多少都可以，什么比例都可以，最为关键是需要在拿到比例后进行通用的处理</span><br></pre></td></tr></table></figure>
<pre><code>/**
 * 裁剪框的比例模式
 *
 * 
 */
public enum CropModeEnum {
    FIT_IMAGE(0), RATIO_2_3(1), RATIO_3_2(2), RATIO_4_3(3), RATIO_3_4(4), SQUARE(5), RATIO_16_9(6), RATIO_9_16(7), FREE(
        8);
    private final int ID;

    CropModeEnum(int id) {
        ID = id;
    }

    public int getID() {
        return ID;
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">需要定义变量</span><br></pre></td></tr></table></figure>
<p>// 裁剪模式，默认比例是自由模式<br>private CropModeEnum mCropMode = CropModeEnum.FREE;<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">计算裁剪框的代码如下：</span><br></pre></td></tr></table></figure></p>
<p>private RectF calculateFrameRect(RectF imageRect) {<br>        float frameW = getRatioX(imageRect.width());<br>        float frameH = getRatioY(imageRect.height());<br>        float frameRatio = frameW / frameH;<br>        float imgRatio = imageRect.width() / imageRect.height();</p>
<pre><code>    float l = imageRect.left, t = imageRect.top, r = imageRect.right, b = imageRect.bottom;
    if (frameRatio &gt;= imgRatio) {
        //宽比长比例大于img图宽高比的情况
        l = imageRect.left;
        r = imageRect.right;
        //图的中点
        float hy = (imageRect.top + imageRect.bottom) * 0.5f;
        //中点到上下顶点坐标的距离
        float hh = (imageRect.width() / frameRatio) * 0.5f;
        t = hy - hh;
        b = hy + hh;
    } else if (frameRatio &lt; imgRatio) {
        //宽比长比例大于img图宽高比的情况
        t = imageRect.top;
        b = imageRect.bottom;
        float hx = (imageRect.left + imageRect.right) * 0.5f;
        float hw = imageRect.height() * frameRatio * 0.5f;
        l = hx - hw;
        r = hx + hw;
    }
    //裁剪框宽度
    float w = r - l;
    //高度
    float h = b - t;
    //中心点
    float cx = l + w / 2;
    float cy = t + h / 2;
    //放大后的裁剪框的宽高
    float sw = w * mInitialFrameScale;
    float sh = h * mInitialFrameScale;
    return new RectF(cx - sw / 2, cy - sh / 2, cx + sw / 2, cy + sh / 2);
}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">其中计算比例的```getRatioX()```如下，通过Switch当前的裁剪模式，返回比例或者当前的图片宽度，```getRatioY()```原理是也是一样的</span><br></pre></td></tr></table></figure>
<p>private float getRatioX(float w) {<br>        switch (mCropMode) {<br>            case FIT_IMAGE:<br>                return mImageRectF.width();<br>            case FREE:<br>                return w;<br>            case RATIO_2_3:<br>                return 2;<br>            case RATIO_3_2:<br>                return 3;<br>            case RATIO_4_3:<br>                return 4;<br>            case RATIO_3_4:<br>                return 3;<br>            case RATIO_16_9:<br>                return 16;<br>            case RATIO_9_16:<br>                return 9;<br>            case SQUARE:<br>                return 1;<br>            default:<br>                return w;<br>        }<br>    }<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">接着我们通过分别计算获取裁剪框后的比例和原drawable图的比例，拿到他们的比例为了判断裁剪的框要处于图片框中的什么位置</span><br></pre></td></tr></table></figure></p>
<pre><code>//获取裁剪模式后计算的比例
float frameRatio = frameW / frameH;
//图片原始比例
float imgRatio = imageRect.width() / imageRect.height();
</code></pre><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">现在我们要做的是，计算出裁剪框的坐标位置，裁剪框的位置可能性有很多，我们可以假设一种来看一下</span><br><span class="line">!<span class="selector-attr">[]</span>(<span class="attribute">https</span>:<span class="comment">//upload-images.jianshu.io/upload_images/3515789-fe64da17871cfd53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">假设我们现在的图为<span class="number">1.5</span>:<span class="number">1</span>的图，如上图的<span class="number">1</span>图。现在裁剪框的设定比例是<span class="number">2</span>:<span class="number">1</span>，那么正常比例下裁剪框是无法充满img的，需要对裁剪框做缩放然后放入img框中，如上图的<span class="number">3</span>图。</span><br><span class="line">根据这种情况，我们要对裁剪框做Rect坐标的定位处理。</span><br></pre></td></tr></table></figure>
<pre><code>float l = imageRect.left, t = imageRect.top, r = imageRect.right, b = imageRect.bottom;
if (frameRatio &gt;= imgRatio) {
    //宽比长比例大于img图宽高比的情况
    l = imageRect.left;
    r = imageRect.right;
    //图的中点
    float hy = (imageRect.top + imageRect.bottom) * 0.5f;
    //中点到上下顶点坐标的距离
    float hh = (imageRect.width() / frameRatio) * 0.5f;
    t = hy - hh;
    b = hy + hh;
} else if (frameRatio &lt; imgRatio) {
    //宽比长比例大于img图宽高比的情况
    t = imageRect.top;
    b = imageRect.bottom;
    float hx = (imageRect.left + imageRect.right) * 0.5f;
    float hw = imageRect.height() * frameRatio * 0.5f;
    l = hx - hw;
    r = hx + hw;
}
</code></pre><figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">首先定义裁剪框的四个边角参数左上角<span class="literal">left</span>、<span class="literal">top</span>，右下角<span class="literal">right</span>、<span class="literal">bottom</span>坐标分别为l，t，r，b。</span><br><span class="line">frameRatio &gt;= imgRatio的情况其实就是上面的示意图的情况，左右<span class="literal">left</span>和<span class="literal">right</span>等同于原img图，<span class="literal">top</span>/<span class="literal">bottom</span>可以根据计算得到的裁剪框的高度<span class="string">``</span><span class="string">`imageRect.width() / frameRatio`</span><span class="string">``</span>去确认。</span><br><span class="line"></span><br><span class="line">	宽度/高度=frameRatio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最后计算得到<span class="literal">top</span>和<span class="literal">bottom</span>的坐标</span><br></pre></td></tr></table></figure>
<pre><code> t = hy - hh;
b = hy + hh;
</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">同理，frameRatio &lt; imgRatio的情况原理和这个类似。</span><br><span class="line"></span><br><span class="line">最后根据这些参数确认实际的裁剪框的区域</span><br></pre></td></tr></table></figure>
<pre><code> //裁剪框宽度
float w = r - l;
//高度
float h = b - t;
//中心点
float cx = l + w / 2;
float cy = t + h / 2;
//放大后的裁剪框的宽高
float sw = w * mInitialFrameScale;
float sh = h * mInitialFrameScale;
return new RectF(cx - sw / 2, cy - sh / 2, cx + sw / 2, cy + sh / 2);
</code></pre><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">```mInitialFrameScale```这个是初始状态下给裁剪框的默认放大比例参数，0-1，设置为1，则充满img的边界，设置为其他值，比如0.2，那会以图片中心点为基准进行缩小。</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 三、绘制</span></span><br><span class="line"></span><br><span class="line"><span class="string">以上全部准备工作做完之后，就可以开始绘制我们最关键的裁剪框了</span></span><br></pre></td></tr></table></figure>
<p> @Override<br>    protected void onDraw(Canvas canvas) {<br>        canvas.drawColor(mBackgroundColor);<br>        //只有初始化完毕了才绘制<br>        if (mIsInitialized) {<br>            setMatrix();//这里一开始绘制裁剪框是没有想到的，后面刷新视图的时候，设置了参数之后需要计算bitmap的情况，需要重新对Bitmap进行矩阵处理<br>            Bitmap bitmap = getBitmap();<br>            if (bitmap != null) {<br>                canvas.drawBitmap(bitmap, mMatrix, mBitmapPaint);<br>                // 画裁剪框<br>                drawCropFrame(canvas);<br>            }<br>        }<br>    }<br><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">1</span>、画背景</span><br><span class="line">画ImageView外围的背景（图片显示之外会存在的空白部分）</span><br></pre></td></tr></table></figure></p>
<p>canvas.drawColor(mBackgroundColor);<br><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">##### <span class="number">2</span>、画Bitmap</span><br></pre></td></tr></table></figure></p>
<p>canvas.drawBitmap(bitmap, mMatrix, mBitmapPaint);<br><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">将bitmap画到已确定位置的mMatrix矩阵中</span><br><span class="line"></span><br><span class="line">##### <span class="number">3</span>、画裁剪框</span><br></pre></td></tr></table></figure></p>
<p>private void drawCropFrame(Canvas canvas) {<br>        drawOverlay(canvas);<br>        drawFrame(canvas);<br>        drawGuidelines(canvas);<br>        drawHandleLines(canvas);<br>   }<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">接下来裁剪框会有覆盖层，透明层，边界线和指导线的绘制</span><br></pre></td></tr></table></figure></p>
<p> /**</p>
<pre><code> * 画裁剪框的半透明覆盖层
 *
 * @param canvas
 */
private void drawOverlay(Canvas canvas) {
    mTranslucentPaint.setStyle(Paint.Style.FILL);
    mTranslucentPaint.setFilterBitmap(true);
    mTranslucentPaint.setColor(mOverlayColor);
    Path path = new Path();
    RectF overlayRectF = new RectF();
    overlayRectF.set(mImageRectF);

    path.addRect(overlayRectF, Path.Direction.CW);
    path.addRect(mFrameRectF, Path.Direction.CCW);
    canvas.drawPath(path, mTranslucentPaint);
}
</code></pre><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">第二部分拿到了图片的<span class="selector-tag">Rect</span>区域，我们这里画半透明覆盖层只要调用路径来处理，这里我们调用了路径了两种不同的方向来添加，以使最终得到的路径是裁剪框之外。（当然这里也可以用路径合成方式的处理）</span><br><span class="line"></span><br><span class="line">```		</span><br><span class="line">		<span class="selector-tag">path</span><span class="selector-class">.addRect</span>(<span class="selector-tag">mFrameRectF</span>, <span class="selector-tag">Path</span><span class="selector-class">.Direction</span><span class="selector-class">.CW</span>);</span><br><span class="line">        <span class="selector-tag">path</span><span class="selector-class">.addRect</span>(<span class="selector-tag">overlayRectF</span>, <span class="selector-tag">Path</span><span class="selector-class">.Direction</span><span class="selector-class">.CCW</span>);</span><br></pre></td></tr></table></figure>
<h5 id="4、画边界线"><a href="#4、画边界线" class="headerlink" title="4、画边界线"></a>4、画边界线</h5><p>属性变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 裁剪外框线框宽度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">float</span> mFrameStrokeWeight = <span class="number">2f</span>;</span><br><span class="line">   <span class="comment">// 外框的颜色</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mFrameColor;</span><br></pre></td></tr></table></figure>
<p>直接拿到FrameRect边界来绘制边界线<br><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 画裁剪框边界线</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param canvas</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="selector-tag">private</span> <span class="selector-tag">void</span> <span class="selector-tag">drawFrame</span>(Canvas canvas) &#123;</span><br><span class="line">      <span class="selector-tag">mFramePaint</span><span class="selector-class">.setStyle</span>(Paint.Style.STROKE);</span><br><span class="line">      <span class="selector-tag">mFramePaint</span><span class="selector-class">.setFilterBitmap</span>(true);</span><br><span class="line">      <span class="selector-tag">mFramePaint</span><span class="selector-class">.setColor</span>(mFrameColor);</span><br><span class="line">      <span class="selector-tag">mFramePaint</span><span class="selector-class">.setStrokeWidth</span>(mFrameStrokeWeight);</span><br><span class="line">      <span class="selector-tag">canvas</span><span class="selector-class">.drawRect</span>(mFrameRectF, mFramePaint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="5、画指导线"><a href="#5、画指导线" class="headerlink" title="5、画指导线"></a>5、画指导线</h5><p>这里同理，只需要拿到裁剪框边界，计算索要的点的位置的点的坐标即可绘制自己想要的线条</p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 画指导线</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * @param canvas</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   private void drawGuidelines(Canvas canvas) &#123;</span><br><span class="line">       mFramePaint.setColor(mGuideColor)<span class="comment">;</span></span><br><span class="line">       mFramePaint.setStrokeWidth(mGuideStrokeWeight)<span class="comment">;</span></span><br><span class="line">       // 从左往右第一个竖线的横坐标</span><br><span class="line">       float x1 = mFrameRectF.<span class="literal">left</span> + (mFrameRectF.<span class="literal">right</span> - mFrameRectF.<span class="literal">left</span>) / <span class="number">3.0</span>f<span class="comment">;</span></span><br><span class="line">       float x2 = mFrameRectF.<span class="literal">right</span> - (mFrameRectF.<span class="literal">right</span> - mFrameRectF.<span class="literal">left</span>) / <span class="number">3.0</span>f<span class="comment">;</span></span><br><span class="line">       // 从上往下第一个横的y坐标</span><br><span class="line">       float y1 = mFrameRectF.<span class="literal">top</span> + (mFrameRectF.<span class="literal">bottom</span> - mFrameRectF.<span class="literal">top</span>) / <span class="number">3.0</span>f<span class="comment">;</span></span><br><span class="line">       float y2 = mFrameRectF.<span class="literal">bottom</span> - (mFrameRectF.<span class="literal">bottom</span> - mFrameRectF.<span class="literal">top</span>) / <span class="number">3.0</span>f<span class="comment">;</span></span><br><span class="line">       // 画竖线</span><br><span class="line">       canvas.drawLine(x1, mFrameRectF.<span class="literal">top</span>, x1, mFrameRectF.<span class="literal">bottom</span>, mFramePaint)<span class="comment">;</span></span><br><span class="line">       canvas.drawLine(x2, mFrameRectF.<span class="literal">top</span>, x2, mFrameRectF.<span class="literal">bottom</span>, mFramePaint)<span class="comment">;</span></span><br><span class="line">       // 画横线</span><br><span class="line">       canvas.drawLine(mFrameRectF.<span class="literal">left</span>, y1, mFrameRectF.<span class="literal">right</span>, y1, mFramePaint)<span class="comment">;</span></span><br><span class="line">       canvas.drawLine(mFrameRectF.<span class="literal">left</span>, y2, mFrameRectF.<span class="literal">right</span>, y2, mFramePaint)<span class="comment">;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="6、画定制四边角的图案"><a href="#6、画定制四边角的图案" class="headerlink" title="6、画定制四边角的图案"></a>6、画定制四边角的图案</h5><p>这里我是在四个角画了线条，由于自由模式有点特殊，自由模式下四条边也可以拉动，所以需要给四个边中间点也绘制图案</p>
<p>变量如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 四角线的长度值</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mHandleSize;</span><br><span class="line">   <span class="comment">// 四角的线宽度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mHandleWidth;</span><br></pre></td></tr></table></figure></p>
<p>主要就是坐标的计算<br><figure class="highlight pony"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 画四角的线</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param canvas</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    private void drawHandleLines(<span class="type">Canvas</span> canvas) &#123;</span><br><span class="line">        mFramePaint.setColor(mHandleColor);</span><br><span class="line">        mFramePaint.setStyle(<span class="type">Paint</span>.<span class="type">Style</span>.<span class="type">FILL</span>);</span><br><span class="line">        <span class="comment">// 指导线最边界（最左/最右/最下/最上）的x和y</span></span><br><span class="line">        float handleLineLeftX = mFrameRectF.left - mHandleWidth;</span><br><span class="line">        float handleLineRightX = mFrameRectF.right + mHandleWidth;</span><br><span class="line">        float handleLineTopY = mFrameRectF.top - mHandleWidth;</span><br><span class="line">        float handleLineBottomY = mFrameRectF.bottom + mHandleWidth;</span><br><span class="line">        <span class="comment">// 左上竖向</span></span><br><span class="line">        <span class="type">RectF</span> ltRectFVertical =</span><br><span class="line">            <span class="function"><span class="keyword">new</span> <span class="title">RectF</span>(handleLineLeftX, handleLineTopY, mFrameRectF.left, handleLineTopY + mHandleSize);</span></span><br><span class="line"><span class="function">        <span class="comment">// 左上横向</span></span></span><br><span class="line"><span class="function">        <span class="title">RectF</span> <span class="title">ltRectFHorizontal</span> =</span></span><br><span class="line"><span class="function">            <span class="title">new</span> <span class="title">RectF</span>(handleLineLeftX, handleLineTopY, handleLineLeftX + mHandleSize, mFrameRectF.top);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">RectF</span> <span class="title">rtRectFHorizontal</span> =</span></span><br><span class="line"><span class="function">            <span class="title">new</span> <span class="title">RectF</span>(handleLineRightX - mHandleSize, handleLineTopY, handleLineRightX, mFrameRectF.top);</span></span><br><span class="line"><span class="function">        <span class="title">RectF</span> <span class="title">rtRectFVertical</span> =</span></span><br><span class="line"><span class="function">            <span class="title">new</span> <span class="title">RectF</span>(mFrameRectF.right, handleLineTopY, handleLineRightX, handleLineTopY + mHandleSize);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">RectF</span> <span class="title">lbRectFVertical</span> =</span></span><br><span class="line"><span class="function">            <span class="title">new</span> <span class="title">RectF</span>(handleLineLeftX, handleLineBottomY - mHandleSize, mFrameRectF.left, mFrameRectF.bottom);</span></span><br><span class="line"><span class="function">        <span class="title">RectF</span> <span class="title">lbRectFHorizontal</span> =</span></span><br><span class="line"><span class="function">            <span class="title">new</span> <span class="title">RectF</span>(handleLineLeftX, mFrameRectF.bottom, handleLineLeftX + mHandleSize, handleLineBottomY);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">RectF</span> <span class="title">rbRectFVertical</span> =</span></span><br><span class="line"><span class="function">            <span class="title">new</span> <span class="title">RectF</span>(mFrameRectF.right, handleLineBottomY - mHandleSize, handleLineRightX, handleLineBottomY);</span></span><br><span class="line"><span class="function">        <span class="title">RectF</span> <span class="title">rbRectFHorizontal</span> =</span></span><br><span class="line"><span class="function">            <span class="title">new</span> <span class="title">RectF</span>(handleLineRightX - mHandleSize, mFrameRectF.bottom, handleLineRightX, handleLineBottomY);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">canvas</span>.<span class="title">drawRect</span>(ltRectFVertical, mFramePaint);</span></span><br><span class="line"><span class="function">        <span class="title">canvas</span>.<span class="title">drawRect</span>(ltRectFHorizontal, mFramePaint);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">canvas</span>.<span class="title">drawRect</span>(rtRectFVertical, mFramePaint);</span></span><br><span class="line"><span class="function">        <span class="title">canvas</span>.<span class="title">drawRect</span>(rtRectFHorizontal, mFramePaint);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">canvas</span>.<span class="title">drawRect</span>(lbRectFVertical, mFramePaint);</span></span><br><span class="line"><span class="function">        <span class="title">canvas</span>.<span class="title">drawRect</span>(lbRectFHorizontal, mFramePaint);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">canvas</span>.<span class="title">drawRect</span>(rbRectFVertical, mFramePaint);</span></span><br><span class="line"><span class="function">        <span class="title">canvas</span>.<span class="title">drawRect</span>(rbRectFHorizontal, mFramePaint);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">if</span> (mCropMode == <span class="type">CropModeEnum</span>.<span class="type">FREE</span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="comment">// 如果当前是自由模式</span></span></span><br><span class="line"><span class="function">            <span class="title">mFramePaint</span>.<span class="title">setStrokeCap</span>(<span class="type">Paint</span>.<span class="type">Cap</span>.<span class="type">ROUND</span>);</span></span><br><span class="line"><span class="function">            <span class="title">mFramePaint</span>.<span class="title">setStrokeWidth</span>(mHandleWidth + <span class="type">SizeUtils</span>.dp2px(<span class="number">2</span>));</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="title">float</span> <span class="title">centerX</span> = <span class="title">mFrameRectF</span>.<span class="title">left</span> + <span class="title">mFrameRectF</span>.<span class="title">width</span>() / 2;</span></span><br><span class="line"><span class="function">            <span class="title">float</span> <span class="title">centerY</span> = <span class="title">mFrameRectF</span>.<span class="title">top</span> + <span class="title">mFrameRectF</span>.<span class="title">height</span>() / 2;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="title">canvas</span>.<span class="title">drawLine</span>(centerX - mHandleSize, mFrameRectF.top, (centerX + mHandleSize), <span class="title">mFrameRectF</span>.<span class="title">top</span>,</span></span><br><span class="line"><span class="function">                <span class="title">mFramePaint</span>);</span></span><br><span class="line"><span class="function">            <span class="title">canvas</span>.<span class="title">drawLine</span>(centerX - mHandleSize, mFrameRectF.bottom, centerX + mHandleSize, mFrameRectF.bottom,</span></span><br><span class="line"><span class="function">                mFramePaint);</span></span><br><span class="line"><span class="function">            <span class="title">canvas</span>.<span class="title">drawLine</span>(mFrameRectF.left, (centerY - mHandleSize), <span class="title">mFrameRectF</span>.<span class="title">left</span>, <span class="title">centerY</span> + <span class="title">mHandleSize</span>,</span></span><br><span class="line"><span class="function">                <span class="title">mFramePaint</span>);</span></span><br><span class="line"><span class="function">            <span class="title">canvas</span>.<span class="title">drawLine</span>(mFrameRectF.right, centerY - mHandleSize, mFrameRectF.right, centerY + mHandleSize,</span></span><br><span class="line"><span class="function">                mFramePaint);</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="四、添加MotionEvent控制-1"><a href="#四、添加MotionEvent控制-1" class="headerlink" title="四、添加MotionEvent控制"></a>四、添加MotionEvent控制</h2><p>手指触摸区域会有10种情况，除了四个边角和边界之外，还有裁剪框中间和裁剪框外部的情况，这里定义一个枚举类来标记这10种情况</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 手指点击的区域枚举类</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@time</span> Created by 2018/8/22 19:00</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">TouchAreaEnum</span> &#123;</span></span><br><span class="line">       CENTER, LEFT_TOP, RIGHT_TOP, LEFT_BOTTOM, RIGHT_BOTTOM, OUT_OF_BOUNDS, CENTER_LEFT, CENTER_TOP, CENTER_RIGHT, CENTER_BOTTOM</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>定义默认的触摸模式</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触摸的情况</span></span><br><span class="line">   <span class="keyword">private</span> TouchAreaEnum mTouchArea = TouchAreaEnum.OUT_OF_BOUNDS;</span><br></pre></td></tr></table></figure>
<p>接下来我们需要在Down事件里记录处理的边界，Move事件里动态判断边界是否需要移动，其他事件里恢复初始的状态</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   <span class="function"><span class="keyword">public</span> boolean <span class="title">onTouchEvent</span>(<span class="params">MotionEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">       </span><br><span class="line">     	<span class="keyword">switch</span> (<span class="keyword">event</span>.getAction()) &#123;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">               onActionDown(<span class="keyword">event</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">               onActionMove(<span class="keyword">event</span>);</span><br><span class="line">           </span><br><span class="line">               <span class="keyword">if</span> (mTouchArea != TouchAreaEnum.OUT_OF_BOUNDS) &#123;</span><br><span class="line">                   <span class="comment">// 阻止父view拦截事件</span></span><br><span class="line">                   getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">               getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">               onActionCancel();</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">               getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br><span class="line">               onActionUp();</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">default</span>: &#123;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="1、按下时计算点击的区域位置"><a href="#1、按下时计算点击的区域位置" class="headerlink" title="1、按下时计算点击的区域位置"></a>1、按下时计算点击的区域位置</h5><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> void onActionDown(MotionEvent event) &#123;</span><br><span class="line">        invalidate();</span><br><span class="line">        mLastX = event.getX();</span><br><span class="line">        mLastY = event.getY();</span><br><span class="line">        handleTouchArea(mLastX, mLastY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;Strong&gt;控制指导线或者边框线的显示&lt;/Strong&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * 处理触摸的边界来控制指导线或者边框线的显示，共5种，四个角和里面的中心部分</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> void handleTouchArea(float x, float y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isInLeftTopCorner(x, y)) &#123;</span><br><span class="line">            mTouchArea = TouchAreaEnum.LEFT_TOP;</span><br><span class="line">            handleGuideAndHandleMode();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInRightTopCorner(x, y)) &#123;</span><br><span class="line">            mTouchArea = TouchAreaEnum.RIGHT_TOP;</span><br><span class="line">            handleGuideAndHandleMode();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInLeftBottomCorner(x, y)) &#123;</span><br><span class="line">            mTouchArea = TouchAreaEnum.LEFT_BOTTOM;</span><br><span class="line">            handleGuideAndHandleMode();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInRightBottomCorner(x, y)) &#123;</span><br><span class="line">            mTouchArea = TouchAreaEnum.RIGHT_BOTTOM;</span><br><span class="line">            handleGuideAndHandleMode();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isInCenterLeftCorner(x, y)) &#123;</span><br><span class="line">            mTouchArea = TouchAreaEnum.CENTER_LEFT;</span><br><span class="line">            handleGuideAndHandleMode();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInCenterTopCorner(x, y)) &#123;</span><br><span class="line">            mTouchArea = TouchAreaEnum.CENTER_TOP;</span><br><span class="line">            handleGuideAndHandleMode();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInCenterRightCorner(x, y)) &#123;</span><br><span class="line">            mTouchArea = TouchAreaEnum.CENTER_RIGHT;</span><br><span class="line">            handleGuideAndHandleMode();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isInCenterBottomCorner(x, y)) &#123;</span><br><span class="line">            mTouchArea = TouchAreaEnum.CENTER_BOTTOM;</span><br><span class="line">            handleGuideAndHandleMode();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isInFrameCenter(x, y)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mGuideShowMode == ShowModeEnum.SHOW_ON_TOUCH)</span><br><span class="line">                mShowGuide = <span class="literal">true</span>;</span><br><span class="line">            mTouchArea = TouchAreaEnum.CENTER;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认情况</span></span><br><span class="line">        mTouchArea = TouchAreaEnum.OUT_OF_BOUNDS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里的关键在于<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<pre><code>if (isInLeftTopCorner(x, y)) {
        mTouchArea = TouchAreaEnum.LEFT_TOP;

        return;
    }

    //判断是否在左上角的边界内
 private boolean isInLeftTopCorner(float x, float y) {
     float dx = x - mFrameRectF.left;
     float dy = y - mFrameRectF.top;
     return isInsideBound(dx, dy);
}

private boolean isInsideBound(float dx, float dy) {
    float d = (float) (Math.pow(dx, 2) + Math.pow(dy, 2));
    return (Math.pow(mHandleSize + mTouchPadding, 2)) &gt;= d;
}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">这里处理的其实就是判断触摸的点是否在边界的有效范围内，比如现在的点是左上角，那么可触摸区域应该是围绕左上角顶点的四周圆形的一块区域。如下图，应该是黄色的一块圆形区域。```isInsideBound（）```做的就是对边界内外的判断。</span><br><span class="line">![](https:<span class="comment">//upload-images.jianshu.io/upload_images/3515789-c697fb8351b24a72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### <span class="number">2</span>、根据第<span class="number">1</span>步点击的区域去判断需不需要对边界进行Move处理</span><br><span class="line"></span><br><span class="line">边界移动也存在很多种情况。总体上可以分为裁剪框整体移动和裁剪框边界移动。</span><br></pre></td></tr></table></figure>
<p>private void onActionMove(MotionEvent event) {<br>        float diffX = event.getX() - mLastX;<br>        float diffY = event.getY() - mLastY;<br>        // 区分点击的区域进行移动<br>        switch (mTouchArea) {<br>            case CENTER: {<br>                moveFrame(diffX, diffY);<br>                break;<br>            }<br>            case LEFT_TOP: {<br>                moveHandleLeftTop(diffX, diffY);<br>                break;<br>            }<br>            case RIGHT_TOP: {<br>                moveHandleRightTop(diffX, diffY);<br>                break;<br>            }<br>            case LEFT_BOTTOM: {<br>                moveHandleLeftBottom(diffX, diffY);<br>                break;<br>            }<br>            case RIGHT_BOTTOM: {<br>                moveHandleRightBottom(diffX, diffY);<br>                break;<br>            }</p>
<pre><code>        case CENTER_LEFT: {
            moveHandleCenterLeft(diffX);
            break;
        }
        case CENTER_TOP: {
            moveHandleCenterTop(diffY);
            break;
        }
        case CENTER_RIGHT: {
            moveHandleCenterRight(diffX);
            break;
        }
        case CENTER_BOTTOM: {
            moveHandleCenterBottom(diffY);
            break;
        }
        case OUT_OF_BOUNDS: {
            break;
        }
    }
    invalidate();
    mLastX = event.getX();
    mLastY = event.getY();
}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- A.针对裁剪框移动进行分析，move事件得到的X,Y只需要交给裁剪边框的RectF处理就大吉大利了，```handleMoveBounds（）```是平移的相反的操作，这种策略可避免产生由于Move数值精度不准确产生的边界问题）</span><br></pre></td></tr></table></figure>
<p>private void moveFrame(float x, float y) {<br>        // 1.先平移（这里采取先平移如果条件不满足再后退的策略，避免产生由于Move数值精度不准确产生的边界问题）<br>        mFrameRectF.left += x;<br>        mFrameRectF.right += x;<br>        mFrameRectF.top += y;<br>        mFrameRectF.bottom += y;<br>        // 2.判断有没有超出界外，如果超出则后退<br>        handleMoveBounds();<br>    }<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>B、针对边框的边界进行处理，处理边框会有2种情况，一种是自由模式下，长宽都可以分别调整，另外一种是确定比例的模式下，长宽需要一起调整的情况</span><br></pre></td></tr></table></figure></p>
<p>private void moveHandleLeftTop(float diffX, float diffY) {<br>        if (mCropMode == CropModeEnum.FREE) {<br>            mFrameRectF.left += diffX;<br>            mFrameRectF.top += diffY;<br>            if (isWidthTooSmall()) {<br>                float offsetX = mFrameMinSize - mFrameRectF.width();<br>                mFrameRectF.left -= offsetX;<br>            }<br>            if (isHeightTooSmall()) {<br>                float offsetY = mFrameMinSize - mFrameRectF.height();<br>                mFrameRectF.top -= offsetY;<br>            }<br>            checkScaleBounds();<br>        } else {<br>            float dx = diffX;<br>            float dy = diffX <em> getRatioY() / getRatioX();<br>            mFrameRectF.left += dx;<br>            mFrameRectF.top += dy;<br>            // 控制缩放边界<br>            if (isWidthTooSmall()) {<br>                float offsetX = mFrameMinSize - mFrameRectF.width();<br>                mFrameRectF.left -= offsetX;<br>                // todo 裁剪框比例控制<br>                float offsetY = offsetX </em> getRatioY() / getRatioX();<br>                mFrameRectF.top -= offsetY;<br>            }<br>            if (isHeightTooSmall()) {<br>                float offsetY = mFrameMinSize - mFrameRectF.height();<br>                mFrameRectF.top -= offsetY;<br>                float offsetX = offsetY * getRatioX() / getRatioY();<br>                mFrameRectF.left -= offsetX;<br>            }</p>
<pre><code>        float ox, oy;
        if (!isInsideX(mFrameRectF.left)) {
            ox = mImageRectF.left - mFrameRectF.left;
            mFrameRectF.left += ox;
            oy = ox * getRatioY() / getRatioX();
            mFrameRectF.top += oy;
        }
        if (!isInsideY(mFrameRectF.top)) {
            oy = mImageRectF.top - mFrameRectF.top;
            mFrameRectF.top += oy;
            ox = oy * getRatioX() / getRatioY();
            mFrameRectF.left += ox;
        }
    }
}
</code></pre><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>A、对自由模式下的边界拖动进行处理</span><br></pre></td></tr></table></figure>
<pre><code>if (mCropMode == CropModeEnum.FREE) {
    //不管发生什么事，先把过来的数值先加上
    mFrameRectF.left += diffX;
    mFrameRectF.top += diffY;
    //判断变化后的边界有没有比限定的最小边界小，如果小，那么就还原
    if (isWidthTooSmall()) {
        float offsetX = mFrameMinSize - mFrameRectF.width();
        mFrameRectF.left -= offsetX;
    }
    if (isHeightTooSmall()) {
        float offsetY = mFrameMinSize - mFrameRectF.height();
        mFrameRectF.top -= offsetY;
    }
    //处理有没有超出最大边界
    checkScaleBounds();
}
</code></pre><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">- </span>B、对非自由模式下的边界的缩放就行处理</span><br></pre></td></tr></table></figure>
<pre><code>//这里只需要监测move事件的x或者y的变化，然后通过设定的比例计算出另外的x或者y的坐标，从而限定裁剪框的比例
float dx = diffX;
float dy = diffX * getRatioY() / getRatioX();

mFrameRectF.left += dx;
mFrameRectF.top += dy;
// 控制缩放边界
if (isWidthTooSmall()) {
    //同上自由模式的控制，这里也是要讲超界的值恢复，只是这里x，y要分别恢复
    float offsetX = mFrameMinSize - mFrameRectF.width();
    mFrameRectF.left -= offsetX;
    float offsetY = offsetX * getRatioY() / getRatioX();
    mFrameRectF.top -= offsetY;
}
if (isHeightTooSmall()) {
    float offsetY = mFrameMinSize - mFrameRectF.height();
    mFrameRectF.top -= offsetY;
    float offsetX = offsetY * getRatioX() / getRatioY();
    mFrameRectF.left -= offsetX;
}
//限制不能让裁剪框超出图片边界
float ox, oy;
if (!isInsideX(mFrameRectF.left)) {
    ox = mImageRectF.left - mFrameRectF.left;
    mFrameRectF.left += ox;
    oy = ox * getRatioY() / getRatioX();
    mFrameRectF.top += oy;
}
if (!isInsideY(mFrameRectF.top)) {
    oy = mImageRectF.top - mFrameRectF.top;
    mFrameRectF.top += oy;
    ox = oy * getRatioX() / getRatioY();
    mFrameRectF.left += ox;
}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">3</span>、抬起时恢复默认的处理状态</span><br><span class="line"></span><br><span class="line">其它点击事件，我们只要恢复默认状态就可</span><br></pre></td></tr></table></figure>
<pre><code> private void onActionCancel() {
    mTouchArea = TouchAreaEnum.OUT_OF_BOUNDS;
    invalidate();
}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 旋转翻转处理</span><br><span class="line"></span><br><span class="line">##### <span class="number">1</span>、左右翻转</span><br><span class="line"></span><br><span class="line">左右翻转和上下翻转只需要用View默认的ScaleX和ScaleY来控制就可以，比如左右翻转</span><br></pre></td></tr></table></figure>
<pre><code>/**
 * 左右翻转
 */
public void reverseY() {
    if (!mIsReverseY) {
        mIsReverseY = true;
    } else {
        mIsReverseY = false;
    }
    super.setScaleX(getScaleX() * -1f);
}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">2</span>、旋转处理</span><br><span class="line"></span><br><span class="line">旋转多少度是个问题，这就跟晚饭吃什么是个问题如此。</span><br><span class="line"></span><br><span class="line">![](https:<span class="comment">//upload-images.jianshu.io/upload_images/3515789-df9d635fbb007f41.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></span><br><span class="line"></span><br><span class="line">这里定义了关于旋转角度的枚举类：</span><br></pre></td></tr></table></figure>
<p>/**</p>
<pre><code> * 旋转角度的枚举类
 *
 * @time Created by 2018/8/22 19:07
 */
public enum RotateDegreesEnum {
    ROTATE_90D(90), ROTATE_180D(180), ROTATE_270D(270), ROTATE_M90D(-90), ROTATE_M180D(-180), ROTATE_M270D(-270), ROTATE_0D(
        0);

    private final int VALUE;

    RotateDegreesEnum(final int value) {
        this.VALUE = value;
    }

    public int getValue() {
        return VALUE;
    }
}
</code></pre><figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">还记得一开始使用的Metrix矩阵吗，我们可以通过它来实现对当前Img的旋转，先计算旋转后的比例和角度变化，然后只要将变化值和起始值终点值放入属性动画中进行驱动就会有旋转时候的动画效果。当然，如果不需要动画（比如下面代码的最后），你可以直接设置终值，然后重新<span class="keyword">layout</span></span><br></pre></td></tr></table></figure>
<pre><code>/**
 * 旋转图片
 *
 * @param degrees
 * @param durationMillis 需要调整的动画时间
 */
private void rotateImage(RotateDegreesEnum degrees, int durationMillis) {
    if (mIsRotating) {
        mValueAnimator.cancel();
    }
    //先计算旋转后的比例和角度变化
    final float currentAngle = mImgAngle;
    //新的角度
    final float newAngle = (mImgAngle + degrees.getValue());
    final float angleDiff = newAngle - currentAngle;
    final float currentScale = mCropScale;
    //旋转后的比例
    final float newScale = calcScale(mViewWidth, mViewHeight, newAngle);

    if (mIsAnimationEnabled) {
        final float scaleDiff = newScale - currentScale;

        mValueAnimator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                super.onAnimationEnd(animation);
                mImgAngle = newAngle % 360;
                mCropScale = newScale;
                doLayout(mViewWidth, mViewHeight);
                mIsRotating = false;
            }

            @Override
            public void onAnimationStart(Animator animation) {
                super.onAnimationStart(animation);
                mIsRotating = true;
            }
        });
        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                //动画关键参数变化
                float scale = (float) animation.getAnimatedValue();
                mImgAngle = currentAngle + angleDiff * scale;
                mCropScale = currentScale + scaleDiff * scale;
                //核心旋转缩放处理
                setMatrix();
                invalidate();
            }
        });
        mValueAnimator.setDuration(durationMillis);
        mValueAnimator.start();
    } else {
        //无动画的情况
        mImgAngle = newAngle % 360;
        mCropScale = newScale;
        doLayout(mViewWidth, mViewHeight);
    }
}
</code></pre><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 六、裁剪</span></span><br><span class="line"></span><br><span class="line"><span class="string">裁剪功能其实最关键的是获取裁剪后的Bitmap，**注意要在工作者线程处理**</span></span><br></pre></td></tr></table></figure>
<pre><code>/**
 * 获取裁剪后的图片（&lt;Strong&gt;Notice：不包含翻转变化&lt;/Strong&gt;）
 *
 * @return
 */
public Bitmap getCroppedBitmap() {
    Bitmap source = getBitmap();
    if (source == null)
        return null;
    Bitmap rotated = getRotatedBitmap(source);
    Rect cropRect = calcCropRect(source.getWidth(), source.getHeight());
    Bitmap cropped =
        Bitmap.createBitmap(rotated, cropRect.left, cropRect.top, cropRect.width(), cropRect.height(), null, false);
    if (rotated != cropped &amp;&amp; rotated != source) {
        rotated.recycle();
    }
    if (mIsReverseY) {
        // 如果翻转了照片，那么对照片进行翻转处理
        cropped = ImgUtils.reverseImg(cropped, -1, 1);
    }
    return cropped;
}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">1</span>、对获取的bitmap进行旋转处理</span><br><span class="line"></span><br><span class="line">其实就是根据现在的旋转角度对Bitmap就行Matrix的处理</span><br></pre></td></tr></table></figure>
<pre><code>/**
 * 得到旋转后的Bitmap
 *
 * @param bitmap
 * @return
 */
private Bitmap getRotatedBitmap(Bitmap bitmap) {
    Matrix rotateMatrix = new Matrix();
    rotateMatrix.postRotate(mImgAngle, bitmap.getWidth() / 2, bitmap.getHeight() / 2);
    return Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), rotateMatrix, true);
}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">##### <span class="number">2</span>、计算裁剪框相对原图的区域</span><br><span class="line">计算原图进行旋转处理后相对原图的宽高比例，然后通过变化得到裁剪框的旋转后的比例</span><br></pre></td></tr></table></figure>
<pre><code>private Rect calcCropRect(int originalImageWidth, int originalImageHeight) {
    //旋转之后的宽
    float rotatedWidth = getRotatedWidth(mImgAngle, originalImageWidth, originalImageHeight);
    //旋转之后的高
    float rotatedHeight = getRotatedHeight(mImgAngle, originalImageWidth, originalImageHeight);
    //旋转后的相对旋转前的比例
    float scaleForOriginal = rotatedWidth / mImageRectF.width();
    float offsetX = mImageRectF.left * scaleForOriginal;
    float offsetY = mImageRectF.top * scaleForOriginal;

    //对旋转后的裁剪框的处理，
    int left = Math.round(mFrameRectF.left * scaleForOriginal - offsetX);
    int top = Math.round(mFrameRectF.top * scaleForOriginal - offsetY);
    int right = Math.round(mFrameRectF.right * scaleForOriginal - offsetX);
    int bottom = Math.round(mFrameRectF.bottom * scaleForOriginal - offsetY);

    int imageW = Math.round(rotatedWidth);
    int imageH = Math.round(rotatedHeight);
    return new Rect(Math.max(left, 0), Math.max(top, 0), Math.min(right, imageW), Math.min(bottom, imageH));
}
</code></pre><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">3</span>、对图片进行翻转处理</span><br></pre></td></tr></table></figure>
<p>if (mIsReverseY) {<br>            // 如果翻转了照片，那么对照片进行翻转处理<br>            cropped = ImgUtils.reverseImg(cropped, -1, 1);<br>        }<br><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### <span class="number">4</span>、拿到裁剪后的图</span><br></pre></td></tr></table></figure></p>
<p> Bitmap cropped =<br>            Bitmap.createBitmap(rotated, cropRect.left, cropRect.top, cropRect.width(), cropRect.height(), null, false);<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 七、开放属性Style</span></span></span><br><span class="line"></span><br><span class="line">为了能在xml中自定义我们想要的属性，针对开头所说的额外考虑的部分和实际coding时所遇到的一些属性进行整理</span><br><span class="line"></span><br><span class="line">得到属性</span><br></pre></td></tr></table></figure></p>
<p><declare-styleable name="CropView"><br>        <attr name="img_src" format="reference"><br>        <attr name="crop_mode"><br>            <enum name="fit_image" value="0"><br>            <enum name="ratio_2_3" value="1"><br>            <enum name="ratio_3_2" value="2"><br>            <enum name="ratio_4_3" value="3"><br>            <enum name="ratio_3_4" value="4"><br>            <enum name="square" value="5"><br>            <enum name="ratio_16_9" value="6"><br>            <enum name="ratio_9_16" value="7"><br>            <enum name="free" value="8"></enum></enum></enum></enum></enum></enum></enum></enum></enum></attr></attr></declare-styleable></p>
<pre><code>    &lt;/attr&gt;
    &lt;attr name=&quot;background_color&quot; format=&quot;reference|color&quot; /&gt;
    &lt;attr name=&quot;overlay_color&quot; format=&quot;reference|color&quot; /&gt;
    &lt;attr name=&quot;frame_color&quot; format=&quot;reference|color&quot; /&gt;
    &lt;attr name=&quot;handle_color&quot; format=&quot;reference|color&quot; /&gt;
    &lt;attr name=&quot;handle_width&quot; format=&quot;dimension&quot; /&gt;
    &lt;attr name=&quot;handle_size&quot; format=&quot;dimension&quot; /&gt;
    &lt;attr name=&quot;guide_color&quot; format=&quot;reference|color&quot; /&gt;
    &lt;attr name=&quot;guide_show_mode&quot;&gt;
        &lt;enum name=&quot;show_always&quot; value=&quot;1&quot; /&gt;
        &lt;enum name=&quot;show_on_touch&quot; value=&quot;2&quot; /&gt;
        &lt;enum name=&quot;not_show&quot; value=&quot;3&quot; /&gt;
    &lt;/attr&gt;
    &lt;attr name=&quot;handle_show_mode&quot;&gt;
        &lt;enum name=&quot;show_always&quot; value=&quot;1&quot; /&gt;
        &lt;enum name=&quot;show_on_touch&quot; value=&quot;2&quot; /&gt;
        &lt;enum name=&quot;not_show&quot; value=&quot;3&quot; /&gt;
    &lt;/attr&gt;
    &lt;attr name=&quot;touch_padding&quot; format=&quot;dimension&quot; /&gt;
    &lt;attr name=&quot;min_frame_size&quot; format=&quot;dimension&quot; /&gt;
    &lt;attr name=&quot;frame_stroke_weight&quot; format=&quot;dimension&quot; /&gt;
    &lt;attr name=&quot;guide_stroke_weight&quot; format=&quot;dimension&quot; /&gt;
    &lt;attr name=&quot;crop_enabled&quot; format=&quot;boolean&quot; /&gt;
    &lt;attr name=&quot;initial_frame_scale&quot; format=&quot;float&quot; /&gt;
&lt;/declare-styleable&gt;
</code></pre><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">加载属性</span><br></pre></td></tr></table></figure>
<p> /**</p>
<pre><code> * 加载Style自定义属性数据
 *
 * @param context
 * @param attrs
 * @param defStyleAttr
 */
private void loadStyleable(Context context, AttributeSet attrs, int defStyleAttr) {
    TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.CropView, defStyleAttr, 0);
    Drawable drawable;
    mCropMode = CropModeEnum.SQUARE;
    try {
        drawable = ta.getDrawable(R.styleable.CropView_img_src);
        if (drawable != null)
            setImageDrawable(drawable);
        for (CropModeEnum mode : CropModeEnum.values()) {
            if (ta.getInt(R.styleable.CropView_crop_mode, 3) == mode.getID()) {
                mCropMode = mode;
                break;
            }
        }
        mBackgroundColor = ta.getColor(R.styleable.CropView_background_color, TRANSPARENT);
        mOverlayColor = ta.getColor(R.styleable.CropView_overlay_color, TRANSLUCENT_BLACK);
        mFrameColor = ta.getColor(R.styleable.CropView_frame_color, WHITE);
        mHandleColor = ta.getColor(R.styleable.CropView_handle_color, WHITE);
        mGuideColor = ta.getColor(R.styleable.CropView_guide_color, TRANSLUCENT_WHITE);
        for (ShowModeEnum mode : ShowModeEnum.values()) {
            if (ta.getInt(R.styleable.CropView_guide_show_mode, 1) == mode.getId()) {
                mGuideShowMode = mode;
                break;
            }
        }

        for (ShowModeEnum mode : ShowModeEnum.values()) {
            if (ta.getInt(R.styleable.CropView_handle_show_mode, 1) == mode.getId()) {
                mHandleShowMode = mode;
                break;
            }
        }
        setGuideShowMode(mGuideShowMode);
        setHandleShowMode(mHandleShowMode);
        mHandleSize = ta.getDimensionPixelSize(R.styleable.CropView_handle_size, SizeUtils.dp2px(HANDLE_SIZE));
        mHandleWidth = ta.getDimensionPixelSize(R.styleable.CropView_handle_width, SizeUtils.dp2px(HANDLE_WIDTH));
        mTouchPadding = ta.getDimensionPixelSize(R.styleable.CropView_touch_padding, 0);
        mFrameMinSize =
                ta.getDimensionPixelSize(R.styleable.CropView_min_frame_size, SizeUtils.dp2px(FRAME_MIN_SIZE));
        mFrameStrokeWeight =
                ta.getDimensionPixelSize(R.styleable.CropView_frame_stroke_weight, SizeUtils.dp2px(FRAME_STROKE_WEIGHT));
        mGuideStrokeWeight =
                ta.getDimensionPixelSize(R.styleable.CropView_guide_stroke_weight, SizeUtils.dp2px(GUIDE_STROKE_WEIGHT));
        mIsCropEnabled = ta.getBoolean(R.styleable.CropView_crop_enabled, true);
        mInitialFrameScale =
                constrain(ta.getFloat(R.styleable.CropView_initial_frame_scale, DEFAULT_INITIAL_SCALE), 0.01f, 1.0f,
                        DEFAULT_INITIAL_SCALE);
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        ta.recycle();
    }
}
</code></pre><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 八、使用</span></span><br><span class="line"></span><br><span class="line"><span class="string">使用第七节的属性像ImageView引入即可</span></span><br></pre></td></tr></table></figure>
<p>&lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>
<relativelayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".MainActivity">

<pre><code>&lt;com.minminaya.crop.CropView
    android:id=&quot;@+id/crop_img&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;583dp&quot;
    android:layout_above=&quot;@+id/rv&quot;
    android:layout_alignParentTop=&quot;true&quot;
    android:layout_centerHorizontal=&quot;true&quot;
    android:padding=&quot;10dp&quot;
    app:crop_enabled=&quot;true&quot;
    app:crop_mode=&quot;free&quot;
    app:background_color=&quot;#66FFFFFF&quot;
    app:frame_color=&quot;@android:color/white&quot;
    app:frame_stroke_weight=&quot;2dp&quot;
    app:guide_color=&quot;#66FFFFFF&quot;
    app:guide_show_mode=&quot;show_always&quot;
    app:guide_stroke_weight=&quot;2dp&quot;
    app:handle_color=&quot;@android:color/white&quot;
    app:handle_show_mode=&quot;show_always&quot;
    app:handle_size=&quot;24dp&quot;
    app:handle_width=&quot;3dp&quot;
    app:initial_frame_scale=&quot;1&quot;
    app:min_frame_size=&quot;100dp&quot;
    app:overlay_color=&quot;#AA1C1C1C&quot;
    app:touch_padding=&quot;8dp&quot; /&gt;

&lt;android.support.v7.widget.RecyclerView
    android:id=&quot;@+id/rv&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;108dp&quot;
    android:layout_alignParentBottom=&quot;true&quot;
    android:background=&quot;@android:color/white&quot; /&gt;
</code></pre><p></p></relativelayout><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">然后Activity中引入</span><br></pre></td></tr></table></figure><p></p>
<p>public class MainActivity extends AppCompatActivity {</p>
<pre><code>private CropView mCropView;
private RecyclerView mRecyclerView;
private CropRecyclerViewAdapter mRecyclerViewAdapter;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    mRecyclerView = findViewById(R.id.rv);
    mCropView = findViewById(R.id.crop_img);
    mRecyclerViewAdapter = new CropRecyclerViewAdapter();

    mCropView.setImageResource(R.mipmap.test_pic);

    if (mRecyclerView != null) {
        mRecyclerViewAdapter = new CropRecyclerViewAdapter();
        // 数据来源
        mRecyclerViewAdapter.setCommonAdapterBean(handleRvAdapterData());
        mRecyclerView.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false));
        mRecyclerView.setAdapter(mRecyclerViewAdapter);
        mRecyclerViewAdapter.setOnItemClickedListener(new CropRecyclerViewAdapter.OnItemClickedListener() {
            @Override
            public void onClicked(View view, int position) {
                handleRvItemClicked(view, position);
            }
        });
    }
}

private CommonAdapterBean handleRvAdapterData() {
    CommonAdapterBean CommonAdapterBean = new CommonAdapterBean();
    List&lt;Integer&gt; funcPics = CommonAdapterBean.getFuncPics();
    List&lt;String&gt; funcNames = CommonAdapterBean.getFuncNames();
    String[] funcNameArrays =
            new String[] {Constant.CropBean.STR_ROTATION, Constant.CropBean.STR_REVERSION,
                    Constant.CropBean.STR_RATIO_FREE, Constant.CropBean.STR_RATIO_SQUARE,
                    Constant.CropBean.STR_RATIO_2_3, Constant.CropBean.STR_RATIO_3_2,
                    Constant.CropBean.STR_RATIO_3_4, Constant.CropBean.STR_RATIO_4_3,
                    Constant.CropBean.STR_RATIO_9_16, Constant.CropBean.STR_RATIO_16_9};
    for (String funcName : funcNameArrays) {
        funcPics.add(R.mipmap.ic_launcher);
        funcNames.add(funcName);
    }
    return CommonAdapterBean;
}

protected void handleRvItemClicked(View view, int position) {
    switch (position) {
        case Constant.CropBean.INDEX_ROTATION: {
            mCropView.rotateImage(CropView.RotateDegreesEnum.ROTATE_M90D);
            break;
        }
        case Constant.CropBean.INDEX_REVERSION: {
            mCropView.reverseY();
            break;
        }
        case Constant.CropBean.INDEX_RATIO_FREE: {
            mCropView.setCropMode(CropView.CropModeEnum.FREE);
            break;
        }
        case Constant.CropBean.INDEX_RATIO_SQUARE: {
            mCropView.setCropMode(CropView.CropModeEnum.SQUARE);
            break;
        }
        case Constant.CropBean.INDEX_RATIO_2_3: {
            mCropView.setCropMode(CropView.CropModeEnum.RATIO_2_3);
            break;
        }
        case Constant.CropBean.INDEX_RATIO_3_2: {
            mCropView.setCropMode(CropView.CropModeEnum.RATIO_3_2);
            break;
        }
        case Constant.CropBean.INDEX_RATIO_3_4: {
            mCropView.setCropMode(CropView.CropModeEnum.RATIO_3_4);
            break;
        }
        case Constant.CropBean.INDEX_RATIO_4_3: {
            mCropView.setCropMode(CropView.CropModeEnum.RATIO_4_3);
            break;
        }
        case Constant.CropBean.INDEX_RATIO_9_16: {
            mCropView.setCropMode(CropView.CropModeEnum.RATIO_9_16);
            break;
        }
        case Constant.CropBean.INDEX_RATIO_16_9: {
            mCropView.setCropMode(CropView.CropModeEnum.RATIO_16_9);
            break;
        }
    }
}
</code></pre><p>}<br><code>`</code></p>
<p>效果如下</p>
<p><img src="https://upload-images.jianshu.io/upload_images/3515789-ed294a65201cd8cf.gif?imageMogr2/auto-orient/strip" alt></p>
<hr>
<p><img src="https://upload-images.jianshu.io/upload_images/3515789-0aa70fedd860fe33.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<hr>
<h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><p>地址：<a href="https://github.com/minminaya/CropViewDemo" target="_blank" rel="noopener">https://github.com/minminaya/CropViewDemo</a></p>
<hr>
<p>参考</p>
<p><a href="https://blog.csdn.net/chunqiuwei/article/details/78858192/" target="_blank" rel="noopener">Android自定义 view之图片裁剪从设计到实现</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/20/2018年Android的保活方案效果统计/" rel="next" title="2018年Android的保活方案效果统计">
                <i class="fa fa-chevron-left"></i> 2018年Android的保活方案效果统计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="minminaya">
            
              <p class="site-author-name" itemprop="name">minminaya</p>
              <p class="site-description motion-element" itemprop="description">啊！你来啦！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/minminaya" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:minminaya@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/43a04ef9d4c6" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-book"></i>简书</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://developer.android.google.cn/index.html" title="Android Developers" target="_blank">Android Developers</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/XXApple/AndroidLibs" title="AndroidLibs" target="_blank">AndroidLibs</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/Freelander/Android_Data" title="Android学习资料" target="_blank">Android学习资料</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://github.com/justjavac/free-programming-books-zh_CN" title="Going Super Man" target="_blank">Going Super Man</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CropView从入门到放弃"><span class="nav-number">1.</span> <span class="nav-text">CropView从入门到放弃</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#你需要准备的"><span class="nav-number">2.</span> <span class="nav-text">你需要准备的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#目录"><span class="nav-number">3.</span> <span class="nav-text">目录</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一、测量"><span class="nav-number">3.0.0.0.1.</span> <span class="nav-text">一、测量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二、布局"><span class="nav-number">3.0.0.0.2.</span> <span class="nav-text">二、布局</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三、绘制"><span class="nav-number">3.0.0.0.3.</span> <span class="nav-text">三、绘制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#四、添加MotionEvent控制"><span class="nav-number">3.0.0.0.4.</span> <span class="nav-text">四、添加MotionEvent控制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#五、旋转翻转处理"><span class="nav-number">3.0.0.0.5.</span> <span class="nav-text">五、旋转翻转处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#六、裁剪"><span class="nav-number">3.0.0.0.6.</span> <span class="nav-text">六、裁剪</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#七、开放属性Style"><span class="nav-number">3.0.0.0.7.</span> <span class="nav-text">七、开放属性Style</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#八、使用"><span class="nav-number">3.0.0.0.8.</span> <span class="nav-text">八、使用</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#额外需要首先考虑的"><span class="nav-number">4.</span> <span class="nav-text">额外需要首先考虑的</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、测量-1"><span class="nav-number">4.1.</span> <span class="nav-text">一、测量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、布局-1"><span class="nav-number">4.2.</span> <span class="nav-text">二、布局</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Bitmap中心点的确定"><span class="nav-number">4.2.0.0.1.</span> <span class="nav-text">1、Bitmap中心点的确定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、图片比例的确定"><span class="nav-number">4.2.0.0.2.</span> <span class="nav-text">2、图片比例的确定</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、画边界线"><span class="nav-number">4.2.0.0.3.</span> <span class="nav-text">4、画边界线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、画指导线"><span class="nav-number">4.2.0.0.4.</span> <span class="nav-text">5、画指导线</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、画定制四边角的图案"><span class="nav-number">4.2.0.0.5.</span> <span class="nav-text">6、画定制四边角的图案</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、添加MotionEvent控制-1"><span class="nav-number">4.3.</span> <span class="nav-text">四、添加MotionEvent控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、按下时计算点击的区域位置"><span class="nav-number">4.3.0.0.1.</span> <span class="nav-text">1、按下时计算点击的区域位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#源代码"><span class="nav-number">4.3.0.0.2.</span> <span class="nav-text">源代码</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">minminaya</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'lzRI5E4EMXDN1jmh8qCNrXmt-gzGzoHsz',
        appKey: 'SdCEwH2N4mmApxndtqBjBGwC',
        placeholder: '来啊快活啊！Biu Biu Biu...',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("lzRI5E4EMXDN1jmh8qCNrXmt-gzGzoHsz", "SdCEwH2N4mmApxndtqBjBGwC");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

</body>
</html>
